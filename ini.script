# 该文件我们准备了一些初始化数据用于测试

INSERT INTO t_blogger(userName,password,PROFILE,nickName,sign,imageName)
values('admin','a66abb5684c45962d887564f08346e8d','等待添加','李威威','简单，诚实。','/static/userImages/liwei.jpg');


INSERT INTO `t_blogtype` (`type_name`, `order_no`) VALUES ('Shiro', 1);

INSERT INTO `t_blog` (`title`, `summary`, `release_date`, `click_hit`, `reply_hit`, `content`, `type_id`, `key_word`) VALUES
('Shiro 学习笔记（1）—— Hello World', '百度百科上对 Shiro 的概括是非常准确的：Apache Shiro是一个强大且易用的Java安全框架,执行身份验证、授权、密码学和会话管理。在这里，我就直接拿来使用了。学习 Shiro 之前，我们要明确两个非常重要的概念：1、认证；2、授权。认证简单地说，就是登录的时候判断你的用户名和密码是否完全匹配，就', '2016-09-15 20:24:01', 14, 0, '<p>百度百科上对 Shiro 的概括是非常准确的：Apache Shiro是一个强大且易用的Java安全框架,执行身份验证、授权、密码学和会话管理。在这里，我就直接拿来使用了。</p><p><br/></p><p>学习 Shiro 之前，我们要明确两个非常重要的概念：1、认证；2、授权。</p><p>认证简单地说，就是登录的时候判断你的用户名和密码是否完全匹配，就是证明你是你。</p><p>授权，是在认证的基础之上，进行角色和权限的授予，就像你到学校去，你出示了你的学生证以后，学校这个机构要授权给你进学生食堂、宿舍的权利，因为你的角色是学生，你不能随意进教室办公室。</p><p><br/></p><p>角色就是一组权限的集合，权限决定了一个用户可以进行怎样的操作。我们通常是把一组权限绑定到一种角色上，再把一个或者多个角色赋给一个用户，这样就实现了权限的控制。</p><p><br/></p><p>角色作为一个权限的集合，方便了我们对权限的管理。</p><p><br/></p><p>这一节，我们使用 Shiro 帮助我们实现一个小小的登录功能。这个登录的功能没有界面，就是通过简单的用户名密码匹配来实现的。但是我们须要借助 Shiro 来完成。</p><p>在以前的项目中，我们做登录的时候，总是把用户名和密码数据放在数据库的数据表对应的字段中。当然 Shiro 也提供了这样的功能，只不过不须要我们自己编写从数据库查询数据，然后进行字符串匹配的代码编写（这个例子我们下一节讲）。</p><p>我们的测试代码的思路：</p><p>将用户登录的用户名和密码信息（以键值对方式）存放在一个配置文件里，然后我们在一个 Main 方法中输入待登录的用户名和密码，使用某个登录的方法，进行登录。</p><p><br/></p><p>实现步骤：</p><p>1、引入 Gradle 依赖</p><pre class="brush:java;toolbar:false">dependencies&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;testCompile(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;group:&nbsp;&quot;junit&quot;,&nbsp;name:&nbsp;&quot;junit&quot;,&nbsp;version:&nbsp;&quot;4.11&quot;\n&nbsp;&nbsp;&nbsp;&nbsp;)\n&nbsp;&nbsp;&nbsp;&nbsp;compile(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;org.apache.shiro:shiro-core:1.2.4&quot;,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;org.slf4j:slf4j-log4j12:1.7.13&quot;\n&nbsp;&nbsp;&nbsp;&nbsp;)\n}</pre><p>2、核心配置文件 shiro.ini 配置</p><pre class="brush:java;toolbar:false">[usrs]\nliwei=123456\nwudi=wudi\nhuzhenyu=huzhenyu\nyuanlian=yuanlian</pre><p>3、编写代码<br/></p><pre class="brush:java;toolbar:false">public&nbsp;class&nbsp;HelloWorld&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Factory&lt;SecurityManager&gt;&nbsp;factory&nbsp;=&nbsp;new&nbsp;IniSecurityManagerFactory(&quot;classpath:shiro.ini&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SecurityManager&nbsp;securityManager&nbsp;=&nbsp;factory.getInstance();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SecurityUtils.setSecurityManager(securityManager);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Subject&nbsp;currentSubject&nbsp;=&nbsp;SecurityUtils.getSubject();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UsernamePasswordToken&nbsp;token&nbsp;=&nbsp;new&nbsp;UsernamePasswordToken(&quot;liwei&quot;,&nbsp;&quot;123456&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currentSubject.login(token);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(UnknownAccountException&nbsp;e)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;无效的用户名&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(IncorrectCredentialsException&nbsp;e)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;密码错误&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(AuthenticationException&nbsp;e)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;登录成功&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currentSubject.logout();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;最后别忘了退出登录（shiro还会做很多操作，从控制台就可以看出）\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currentUser.logout();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;退出登录成功&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}</pre><p><br/></p><p>说明：我们可以把前台在表单中输入用户名和密码传入&nbsp;UsernamePasswordToken 的构造函数中，Shiro 就会把 UsernamePasswordToken 和配置文件 shiro.ini 中 [usrs] 节点下的键值对进行比对，如果不能匹配则抛出响应的异常。&nbsp;</p><p><br/></p><p>我们简单介绍一下 Shiro 在其中发挥的作用：</p><p>1、Subject 就是我们登录的主体，这里相当于一个桥梁，我们所有的操作其实都要通过 Subject 来帮助我们完成。</p><p>2、SecurityManager 类似于 Spring MVC 中的 DispatcherServlet ，起到类似前端控制器的作用；</p><p>3、在 Shiro 中还有一个非常重要的模块，那就是 Realm ，Realm 是安全数据源，我们要把类似于用户名和密码的信息存放到 Realm 中，Shiro 就可以帮助我们完成认证和授权等一系列操作。</p><p><br/></p><p>在这个例子中的 Realm 叫 IniRealm ，我们把正确的用户名和密码信息存放在一个以 ini 结尾的文件中，Shiro 来帮助我们去做最最简单的字符串匹配，我们只须要通过捕获 Shiro 抛出的响应的异常，做一些后续的处理。将来我们还可以使用 JdbcRealm 和自定义的 Realm。</p><p><br/></p><p>下一节我们介绍如何使用 JdbcRealm 让 Shiro 通过存放在数据库中的用户信息实现用户登录匹配。&nbsp;<br/></p>', 1, 'Shiro'),
('Shiro 学习笔记（2）—— JdbcRealm', '有了 Shiro 的 HelloWorld 以后，我们就对 Shiro 有了一个基本的认识，下面我们直接上代码来说明如何使用 JdbcRealm。1、添加 Gradle 依赖testCompile group: ''junit'', name: ''junit'', version: ''4.12''compile ''o', '2016-09-15 20:36:21', 5, 0, '<p>有了 Shiro 的 HelloWorld 以后，我们就对 Shiro 有了一个基本的认识，下面我们直接上代码来说明如何使用 JdbcRealm。<br/></p><p><br/></p><p>1、添加 Gradle 依赖</p><pre class="brush:groovy;toolbar:false">testCompile&nbsp;group:&nbsp;&#39;junit&#39;,&nbsp;name:&nbsp;&#39;junit&#39;,&nbsp;version:&nbsp;&#39;4.12&#39;\ncompile&nbsp;&#39;org.apache.shiro:shiro-core:1.2.2&#39;\ncompile(&quot;org.slf4j:slf4j-api:1.7.21&quot;)\ncompile(&quot;org.slf4j:slf4j-log4j12:1.7.21&quot;)\ncompile(&quot;com.alibaba:druid:1.0.19&quot;)\ncompile(&quot;mysql:mysql-connector-java:5.1.39&quot;)\ncompile(&quot;commons-logging:commons-logging:1.2&quot;)</pre><p>2、编写 shiro.ini 配置</p><pre class="brush:groovy;toolbar:false">[main]\njdbcRealm=org.apache.shiro.realm.jdbc.JdbcRealm\ndataSource=&nbsp;com.alibaba.druid.pool.DruidDataSource\n#&nbsp;数据源还可以使用&nbsp;C3P0&nbsp;的数据源\n#&nbsp;dataSource=com.mchange.v2.c3p0.ComboPooledDataSource\ndataSource.username=root\ndataSource.password=123456\ndataSource.url=jdbc:mysql://localhost:3306/db_shiro\ndataSource.driverClassName=com.mysql.jdbc.Driver\njdbcRealm.dataSource=$dataSource\nsecurityManager.realms=$jdbcRealm</pre><p>3、编写 SQL ，制造数据</p><pre class="brush:java;toolbar:false">CREATE&nbsp;DATABASE&nbsp;db_shiro&nbsp;DEFAULT&nbsp;CHARACTER&nbsp;SET&nbsp;utf8&nbsp;COLLATE&nbsp;utf8_general_ci;\nUSE&nbsp;db_shiro;\nDROP&nbsp;TABLE&nbsp;IF&nbsp;EXISTS&nbsp;users;\nCREATE&nbsp;TABLE&nbsp;users(\n&nbsp;&nbsp;id&nbsp;INT&nbsp;PRIMARY&nbsp;KEY&nbsp;AUTO_INCREMENT&nbsp;COMMENT&nbsp;&#39;用户表主键&#39;,\n&nbsp;&nbsp;userName&nbsp;VARCHAR(20)&nbsp;COMMENT&nbsp;&#39;用户名&#39;,\n&nbsp;&nbsp;PASSWORD&nbsp;VARCHAR(20)&nbsp;COMMENT&nbsp;&#39;密码&#39;\n);\n\nINSERT&nbsp;INTO&nbsp;users&nbsp;(userName,PASSWORD)\nVALUES&nbsp;(&#39;liwei&#39;,&#39;123456&#39;),(&#39;zhouguang&#39;,&#39;666666&#39;);</pre><p>4、编写测试代码</p><pre class="brush:java;toolbar:false">public&nbsp;class&nbsp;ShiroUtil&nbsp;{\n	//&nbsp;注意：这里&nbsp;SecurityManager&nbsp;所在的包名\n&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;读取配置文件，初始化SecurityManager工厂\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Subject&nbsp;login(String&nbsp;configFileName,String&nbsp;userName,String&nbsp;password){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Factory&lt;SecurityManager&gt;&nbsp;factory&nbsp;=&nbsp;new&nbsp;IniSecurityManagerFactory(&quot;classpath:&quot;+configFileName);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SecurityManager&nbsp;securityManager=&nbsp;factory.getInstance();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;把&nbsp;securityManager&nbsp;的实例绑定到&nbsp;SecurityUtils&nbsp;上\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SecurityUtils.setSecurityManager(securityManager);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;得到当前执行的用户\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Subject&nbsp;currentUser&nbsp;=&nbsp;SecurityUtils.getSubject();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;自己创建一个令牌\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UsernamePasswordToken&nbsp;token&nbsp;=&nbsp;new&nbsp;UsernamePasswordToken(userName,password);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;开始由&nbsp;Shiro&nbsp;帮助我们完成身份认证的逻辑\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currentUser.login(token);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;登录成功！&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(UnknownAccountException&nbsp;e)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;无效的用户名&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}catch&nbsp;(IncorrectCredentialsException&nbsp;e){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;错误的密码&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}catch&nbsp;(AuthenticationException&nbsp;e){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;currentUser;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}</pre><p>可以看到我们的测试代码其实和上一节的 HelloWorld 是一样的，我们还是用的 IniRealm 作为安全数据源。只不过我们配置了数据源和 JdbcRealm。此时数据表和字段的名称都是 Shiro 框架规定好的，表名和字段名都必须这么起，严重耦合。</p><p>当然，我们还可以使用其它的 Realm ，更灵活地实现认证功能。</p>', 1, 'Shiro'),
('Shiro 学习笔记（3）—— 自定义 Realm', '前面两节我们已经介绍过 IniRealm 和 JdbcRealm，这一节我们介绍自定义的 Realm 实现我们自己的安全数据源。方式一：implements Realm （这种方式不太常用，只是为了说明知识）这种方式实现的 Realm 仅只能实现认证操作，并不能实现授权操作。代码：public class M', '2016-09-16 09:37:23', 5, 0, '<p>前面两节我们已经介绍过 IniRealm 和 JdbcRealm，这一节我们介绍自定义的 Realm 实现我们自己的安全数据源。</p><p>方式一：implements Realm （这种方式不太常用，只是为了说明知识）</p><p>这种方式实现的 Realm 仅只能实现认证操作，并不能实现授权操作。</p><p>代码：</p><pre class="brush:java;toolbar:false">public&nbsp;class&nbsp;MapRealm&nbsp;implements&nbsp;Realm&nbsp;{\n\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;Map&lt;String,String&gt;&nbsp;users;\n\n&nbsp;&nbsp;&nbsp;&nbsp;static{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;users&nbsp;=&nbsp;new&nbsp;HashMap&lt;&gt;();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;users.put(&quot;liwei&quot;,&quot;123456&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;users.put(&quot;zhouguang&quot;,&quot;666666&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n\n\n&nbsp;&nbsp;&nbsp;&nbsp;/**\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;返回一个唯一的&nbsp;Realm&nbsp;名字\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@return\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;String&nbsp;getName()&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Map&nbsp;Realm&nbsp;中设置&nbsp;Realm&nbsp;名字的方法&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&quot;MyStaticRealm&quot;;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n\n&nbsp;&nbsp;&nbsp;&nbsp;/**\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;判断此&nbsp;Realm&nbsp;是否支持此&nbsp;Token\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;authenticationToken\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@return\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;boolean&nbsp;supports(AuthenticationToken&nbsp;authenticationToken)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Map&nbsp;Realm&nbsp;中给出支持的&nbsp;Token&nbsp;的方法&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;表示仅支持&nbsp;UsernamePasswordToken&nbsp;类型的&nbsp;Token\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;authenticationToken&nbsp;instanceof&nbsp;UsernamePasswordToken;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n\n&nbsp;&nbsp;&nbsp;&nbsp;/**\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;根据&nbsp;Token&nbsp;获取认证信息\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;authenticationToken\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@return\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@throws&nbsp;AuthenticationException\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;AuthenticationInfo&nbsp;getAuthenticationInfo(AuthenticationToken&nbsp;authenticationToken)&nbsp;throws&nbsp;AuthenticationException&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Map&nbsp;Realm&nbsp;中返回认证信息的方法&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;userName&nbsp;=&nbsp;(String)authenticationToken.getPrincipal();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;password&nbsp;=&nbsp;new&nbsp;String((char[])authenticationToken.getCredentials());\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;token&nbsp;中的用户名：&quot;&nbsp;+&nbsp;userName);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;token&nbsp;中的密码：&quot;&nbsp;+&nbsp;password);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(!users.containsKey(userName)){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;UnknownAccountException(&quot;没有这个用户！&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else&nbsp;if(!password.equals(users.get(userName))){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;IncorrectCredentialsException(&quot;密码错误！&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;SimpleAuthenticationInfo(userName,password,getName());\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}</pre><p>接下来我们要在 shiro.ini 文件中声明我们要是用的这个 Realm。</p><pre class="brush:java;toolbar:false">[main]\n#&nbsp;声明了我们自己定义的一个&nbsp;Realm\nmyMapRealm=com.liwei.realm.MapRealm\n#&nbsp;将我们自己定义的&nbsp;Realm&nbsp;注入到&nbsp;securityManager&nbsp;的&nbsp;realms&nbsp;属性中去\nsecurityManager.realms=$myMapRealm</pre><p>方式二：extends AuthorizingRealm（比较常用的一种方法，因为这样做既可以实现认证操作，也可以实现授权操作）</p><p>示例代码：</p><pre class="brush:java;toolbar:false">public&nbsp;class&nbsp;MyStaticRealm&nbsp;extends&nbsp;AuthorizingRealm&nbsp;{\n\n&nbsp;&nbsp;&nbsp;&nbsp;/**\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;用于授权\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;principalCollection\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@return\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/\n&nbsp;&nbsp;&nbsp;&nbsp;@Override\n&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;AuthorizationInfo&nbsp;doGetAuthorizationInfo(PrincipalCollection&nbsp;principalCollection)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;暂时忽略，以后介绍\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;null;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n\n&nbsp;&nbsp;&nbsp;&nbsp;/**\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;用于认证\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;token\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@return\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@throws&nbsp;AuthenticationException\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/\n&nbsp;&nbsp;&nbsp;&nbsp;@Override\n&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;AuthenticationInfo&nbsp;doGetAuthenticationInfo(AuthenticationToken&nbsp;token)&nbsp;throws&nbsp;AuthenticationException&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Static&nbsp;Realm&nbsp;中认证的方法&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;userName&nbsp;=&nbsp;token.getPrincipal().toString();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;password&nbsp;=&nbsp;new&nbsp;String((char[])token.getCredentials());\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(!&quot;liwei&quot;.equals(userName)){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;UnknownAccountException(&quot;无效的用户名&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else&nbsp;if(!&quot;123456&quot;.equals(password)){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;IncorrectCredentialsException(&quot;密码无效&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;SimpleAuthenticationInfo(&quot;liweipower@gmail&quot;,&quot;123456&quot;,getName());\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}</pre><p>说明：上面的写作也只是为了测试，真正在生产环境中，应该通过查询数据库去完成认证和授权的相关操作。</p><p>在&nbsp;doGetAuthenticationInfo() 方法中须要返回一个正确的&nbsp;SimpleAuthenticationInfo 对象，这样 Shiro 就会和 Subject 的 login() 方法中传入的 token 信息进行比对，完成认证的操作。</p><p>下面我们在 shiro.ini 中也要配置这个自定义的 Realm：</p><p>代码：</p><pre class="brush:java;toolbar:false">[main]\nmyStaticRealm=com.liwei.realm.MyStaticRealm\nsecurityManager.realms=$myStaticRealm</pre><hr/><p>知识点：配置认证策略</p><p>这时候，我们会有一个疑问，securityManager 的属性既然是 realms，说明可以设置若干个 Realm，它们认证的顺序是如何的呢。</p><p>Shiro 会按照我们声明的顺序，依次验证。在使用了 ini 文件启动 Shiro 的方式中，IniRealm 在 Shiro 中是默认使用的（我个人觉得应该是第一个使用的，即使在我们不声明的情况下）。</p><p>那么对于若干个&nbsp;Realm，Shiro 提供了一种配置方式，让我们来决定在多个 Reaml 同时声明的情况下，采用哪些 Realm 返回的认证信息的方式，这就是我们的认证策略。</p><p>认证策略主要有以下三种：</p><p>1、FirstSuccessfulStrategy：只要有一个 Realm 验证成功即可，只返回第一个 Realm 身份验证成功的认证信息，其他的忽略；</p><p>2、AtLeastOneSuccessfulStrategy： （这是默认使用的认证策略，即在不配置情况下 Shiro 所采用的认证策略）只要有一个 Realm 验证成功即可， 和 FirstSuccessfulStrategy 不同，返回所有 Realm 身份验证成功的认证信息；</p><p>3、AllSuccessfulStrategy：所有 Realm 验证成功才算成功，且返回所有 Realm 身份验证成功的认证信息，如果有一个失败就失败了。</p><p>配置示例：</p><pre class="brush:java;toolbar:false">#&nbsp;配置认证策略\nallSuccessfulStrategy=org.apache.shiro.authc.pam.AllSuccessfulStrategy\nsecurityManager.authenticator.authenticationStrategy=$allSuccessfulStrategy</pre><p>配置好以后，我们可以通过以下的方法来验证我们刚刚配置的&nbsp;Shiro 的认证策略。</p><pre class="brush:java;toolbar:false">currentSubject.login(token);\nPrincipalCollection&nbsp;ps&nbsp;=&nbsp;currentSubject.getPrincipals();\nSystem.out.println(ps.asList());\nSystem.out.println(ps.getRealmNames());\nSystem.out.println(currentSubject.getPrincipals());</pre><p>自定义 Realm 就介绍到这里了。自定义 Realm 是很重要的，特别是&nbsp;extends AuthorizingRealm 这种方式。</p><p><br/></p><p>学习到这里想再强调一下 extends AuthorizingRealm 这种方式覆写的&nbsp;doGetAuthenticationInfo() 方法，一开始我不是很明白，这个方法到底是做什么的，就上面我们举例，我想再解释一下。</p><p>一般地，我们从参数&nbsp;AuthenticationToken 对象中取出用户填写的用户名和密码信息，这个 token 其实就是 Subject 使用 login() 方法中传入的&nbsp;UsernamePasswordToken 对象，我们通过这个 UsernamePasswordToken 对象获得用户填写的用户名和密码，然后我们应该通过用户的用户名去数据库查询数据库是否有这个用户名，如果没有，抛出一个用户名不存在异常；如果用户名存在，返回一个用户对象（带密码的），再用数据库返回的密码数据和用户填写的密码数据进行比对，如果错误，就抛出异常，如果正确，就要把正确的用户名和密码信息封装成一个&nbsp;SimpleAuthenticationInfo 对象返回，这才是一个比较完整并且正确的流程。</p><p><br/></p><p>另外再补充一下，我在上面的例子中说到“用户填写的用户名和密码”是一种为了方便理解的说法。下面介绍官方正确的说法。</p><p>principals：身份，即主体的标识属性，可以是任何东西，如用户名、邮箱等，唯一即可。一个主体可以有多个 principals， 但只有一个 Primary principals， 一般是用户名/密码/手机号。</p><p>credentials：证明/凭证，即只有主体知道的安全值，如密码/数字证书等。</p><p>最常见的 principals 和 credentials 组合就是用户名/密码了。</p>', 1, 'Shiro'),
('Shiro 学习笔记（4）—— 基于字符串的角色和权限', '在 Shiro 中默认对角色和权限的定义和解析都是通过字符串来完成的。对于字符串的说明，在 Shiro 的官方文档和张开涛老师的博客上都有详细的说明。我们现在来看一个例子。我们在 Shiro 的核心配置文件 shiro.ini 中写到：[users]liwei=123456,role1,role2zhougu', '2016-09-16 10:27:38', 5, 0, '<p>在 Shiro 中默认对角色和权限的定义和解析都是通过字符串来完成的。对于字符串的说明，在 Shiro 的官方文档和张开涛老师的博客上都有详细的说明。我们现在来看一个例子。我们在 Shiro 的核心配置文件 shiro.ini 中写到：[users]liwei=123456,role1,role2zhougu(String),</p><p>在 Shiro 中默认对角色和权限的定义和解析都是通过字符串来完成的。</p><p>对于字符串的说明，在 Shiro 的官方文档和张开涛老师的博客上都有详细的说明。</p><p>我们现在来看一个例子。</p><p>我们在 Shiro 的核心配置文件 shiro.ini 中写到：<br/></p><pre class="brush:java;toolbar:false">[users]\nliwei=123456,role1,role2\nzhouguang=666666,role1\n[roles]\nrole1=user:select\nrole2=user:add,user:update,user:delete</pre><p>说明：role1、role2 是表示角色定义的字符串，声明在 [roles] 这个节点下面。<br/></p><p>对于角色具体有哪些权限，可以定义在角色名称的右边，不同的权限用逗号分开。</p><p><br/></p><p>接下来，我们通过代码来展示 Shiro 是如何进行角色和权限的“验证”的。</p><pre class="brush:java;toolbar:false">public&nbsp;class&nbsp;PermissionTest&nbsp;{\n\n&nbsp;&nbsp;&nbsp;&nbsp;@Test\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;testIsPermitted(){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Subject&nbsp;currentUser&nbsp;=&nbsp;ShiroUtil.login(&quot;shiro.ini&quot;,&quot;liwei&quot;,&quot;123456&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean&nbsp;b1&nbsp;=&nbsp;currentUser.isPermitted(&quot;user:select&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(b1);\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean[]&nbsp;results&nbsp;=&nbsp;currentUser.isPermitted(&quot;user:select&quot;,&quot;user:update&quot;,&quot;user:delete&quot;,&quot;user:insert&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(results[0]);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(results[1]);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(results[2]);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(results[3]);\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean&nbsp;b2&nbsp;=currentUser.isPermittedAll(&quot;user:select&quot;,&quot;user:update&quot;,&quot;user:delete&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(b2);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n\n&nbsp;&nbsp;&nbsp;&nbsp;@Test\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;testCheckPermitted(){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Subject&nbsp;currentUser&nbsp;=&nbsp;ShiroUtil.login(&quot;shiro.ini&quot;,&quot;liwei&quot;,&quot;123456&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currentUser.checkPermission(&quot;user:select&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;currentUser.checkPermission(&quot;user:update&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currentUser.checkPermissions(&quot;user:select&quot;,&quot;user:update&quot;,&quot;user:delete&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}</pre><p>说明：上面的代码使用&nbsp;isPermitted() 方法判断这个登录的用户是否具有参数字符串所表示的权限，返回一个 boolean 类型的值。</p><p>checkPermission() 和&nbsp;isPermitted() 方法的功能是类似的，区别在于如果这个登录的用户不具有参数字符串所表示的权限时，程序将抛出异常。</p><p><br/></p><p>类似地，hasRole() 和 checkRole() 方法也有类似的作用，在这里就不多做解释了。</p><p><br/></p><p>那么，Shiro 的这种基于字符串的角色和权限验证方式能不能修改呢，这是完全可以的，这就体现了 Shiro 和绝大多数框架的一个设计风格和原则，你可以用它的东西，也可以扩展它的东西。</p><p><br/></p><p>不过我们首先要知道 Shiro 默认对于角色和权限判断的流程是什么。</p><p>先来说权限，我们要认识一个很重要的接口 WildcardPermission ，这是基于通配符的一个权限匹配接口，下面的两种写法是等价的：</p><pre class="brush:java;toolbar:false">subject().checkPermission(&quot;menu:view:1&quot;);\nsubject().checkPermission(new&nbsp;WildcardPermission(&quot;menu:view:1&quot;));</pre><p>这说明，Shiro 默认使用&nbsp;WildcardPermission 进行权限匹配。</p><p>其次，我们还要知道 PermissionResolver 这个接口，它用于解析权限字符串到 Permission 实例。</p><p><br/></p><p><br/></p><p><br/></p><p>(String)</p>', 1, 'Shiro'),
('Shiro 学习笔记（5）—— 自定义角色权限解析器', '步骤1：实现 Permission 接口public class MyPermission implements Permission {    private String resourceId;    private String operator;    private String instanceI', '2016-09-16 13:07:03', 4, 0, '<p style="white-space: normal;">步骤1：实现&nbsp;Permission 接口</p><pre class="brush:java;toolbar:false">public&nbsp;class&nbsp;MyPermission&nbsp;implements&nbsp;Permission&nbsp;{\n\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;resourceId;\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;operator;\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;instanceId;\n\n&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;这里为了说明问题，省略了&nbsp;get&nbsp;和&nbsp;set&nbsp;方法\n&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;同时&nbsp;get&nbsp;和&nbsp;set&nbsp;方法只会在这个类的内部使用，所以其实没有必要设置和对外开放\n&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;调用方法也会消耗更多内存\n&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;MyPermission(){\n\n&nbsp;&nbsp;&nbsp;&nbsp;}\n\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;MyPermission(String&nbsp;permissionStr){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String[]&nbsp;strs&nbsp;=&nbsp;permissionStr.split(&quot;\\\\+&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(strs.length&gt;1){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.resourceId&nbsp;=&nbsp;strs[1];\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(this.resourceId&nbsp;==&nbsp;null&nbsp;||&nbsp;&quot;&quot;.equals(this.resourceId)){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.resourceId&nbsp;=&nbsp;&quot;*&quot;;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(strs.length&gt;2){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.operator&nbsp;=&nbsp;strs[2];\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(strs.length&gt;3){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.instanceId&nbsp;=&nbsp;strs[3];\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(this.instanceId&nbsp;==&nbsp;null&nbsp;||&nbsp;&quot;&quot;.equals(this.instanceId)){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.instanceId&nbsp;=&nbsp;&quot;*&quot;;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;实例化&nbsp;MyPermission&nbsp;时&nbsp;=&gt;&nbsp;&quot;&nbsp;+&nbsp;this.toString());\n&nbsp;&nbsp;&nbsp;&nbsp;}\n\n\n&nbsp;&nbsp;&nbsp;&nbsp;/**\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;【这是一个非常重要的方法】\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;由程序员自己编写授权是否匹配的逻辑，\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;我们这里的实现，是将&nbsp;Realm&nbsp;中给出的&nbsp;Permission&nbsp;和&nbsp;ini&nbsp;配置中指定的&nbsp;PermissionResoler&nbsp;中指定的&nbsp;Permission&nbsp;进行比对\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;比对的规则完全由我们自己定义\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;permission\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@return\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/\n&nbsp;&nbsp;&nbsp;&nbsp;@Override\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;boolean&nbsp;implies(Permission&nbsp;permission)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(!(permission&nbsp;instanceof&nbsp;MyPermission)){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MyPermission&nbsp;mp&nbsp;=&nbsp;(MyPermission)permission;\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(!&quot;*&quot;.equals(mp.resourceId)&nbsp;&amp;&amp;&nbsp;!this.resourceId.equals(mp.resourceId)){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(!&quot;*&quot;.equals(mp.operator)&nbsp;&amp;&amp;&nbsp;!this.operator.equals(mp.operator)){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(!&quot;*&quot;.equals(mp.instanceId)&nbsp;&amp;&amp;&nbsp;!this.instanceId.equals(mp.instanceId)){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n\n\n&nbsp;&nbsp;&nbsp;&nbsp;@Override\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;String&nbsp;toString()&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&quot;MyPermission{&quot;&nbsp;+\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;resourceId=&#39;&quot;&nbsp;+&nbsp;resourceId&nbsp;+&nbsp;&#39;\\&#39;&#39;&nbsp;+\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;,&nbsp;operator=&#39;&quot;&nbsp;+&nbsp;operator&nbsp;+&nbsp;&#39;\\&#39;&#39;&nbsp;+\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;,&nbsp;instanceId=&#39;&quot;&nbsp;+&nbsp;instanceId&nbsp;+&nbsp;&#39;\\&#39;&#39;&nbsp;+\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;}&#39;;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}</pre><p style="white-space: normal;">步骤2：实现 PermissionResolver 接口</p><p style="white-space: normal;">实现 PermissionResolver&nbsp;接口的意义在于告诉 Shiro 根据字符串的表现形式，采用什么样的 Permission 进行匹配。&nbsp;</p><p style="white-space: normal;">代码：</p><pre class="brush:java;toolbar:false">public&nbsp;class&nbsp;MyPermissionResolver&nbsp;implements&nbsp;PermissionResolver{\n&nbsp;&nbsp;&nbsp;&nbsp;@Override\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Permission&nbsp;resolvePermission(String&nbsp;s)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(s.startsWith(&quot;+&quot;)){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;MyPermission(s);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;WildcardPermission(s);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}</pre><p style="white-space: normal;">说明：这段代码实现的一个配置是：如果我们的权限字符串是以 “+” 号开头的话，就使用我们自定义的&nbsp;MyPermission ，否则就使用默认的&nbsp;WildcardPermission 解析这个字符串。</p><p style="white-space: normal;"><br/></p><p style="white-space: normal;">到这里，我们还要明确的一个知识点是，只有在我们的 Realm 的实现类中，有关于&nbsp;protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) 方法的实现，并且在调用 Shiro 的认证成功以后的 isPermitted() 方法或者&nbsp;checkPermission() 方法的时候，Shiro 才会去执行权限匹配的流程。</p><p style="white-space: normal;"><br/></p><p style="white-space: normal;">这里，我们还是使用刚刚用的 StaticRealm 去实现授权操作，代码：</p><pre class="brush:java;toolbar:false">public&nbsp;class&nbsp;MyStaticRealm&nbsp;extends&nbsp;AuthorizingRealm&nbsp;{\n\n&nbsp;&nbsp;&nbsp;&nbsp;/**\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;用于授权\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;principalCollection\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@return\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/\n&nbsp;&nbsp;&nbsp;&nbsp;@Override\n&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;AuthorizationInfo&nbsp;doGetAuthorizationInfo(PrincipalCollection&nbsp;principalCollection)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;static&nbsp;Realm&nbsp;中授权的方法&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SimpleAuthorizationInfo&nbsp;info&nbsp;=&nbsp;new&nbsp;SimpleAuthorizationInfo();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;info.addRole(&quot;r1&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;info.addRole(&quot;r2&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;info.addStringPermission(&quot;+user+&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;info.addObjectPermission(new&nbsp;MyPermission(&quot;+user+add+1&quot;));\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;info;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n\n&nbsp;&nbsp;&nbsp;&nbsp;/**\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;用于认证\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;token\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@return\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@throws&nbsp;AuthenticationException\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/\n&nbsp;&nbsp;&nbsp;&nbsp;@Override\n&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;AuthenticationInfo&nbsp;doGetAuthenticationInfo(AuthenticationToken&nbsp;token)&nbsp;throws&nbsp;AuthenticationException&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;省略，同上面的例子\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}</pre><p style="white-space: normal;">在 shiro.ini 文件中增加配置：</p><pre class="brush:java;toolbar:false">permissionResolver=com.liwei.permission.MyPermissionResolver\nauthorizer.permissionResolver=$permissionResolver\nsecurityManager.authorizer=$authorizer</pre><p style="white-space: normal;"><br/></p><p style="white-space: normal;">代码其实就是上面的样子，但是光这么讲很抽象，此时权限匹配的过程是定义在我们实现的&nbsp;Permission 接口的&nbsp;implies() 方法中。所以我们还要详细介绍&nbsp;Shiro 在进行权限匹配的流程：</p><p style="white-space: normal;">1、首先调用 Subject.isPermitted* 接口，其会委托给 SecurityManager，而 SecurityManager 接着会委托给 Authorizer；</p><p style="white-space: normal;">2、Authorizer 是真正的授权者，</p><p style="white-space: normal;">如果我们调用如 isPermitted(“user:view”)，其首先会通过 PermissionResolver 把字符串转换成相应的 Permission 实例，注意：这个实例是如何转换的呢？</p><p style="white-space: normal;">根据我们在 shiro.ini 文件中配置的&nbsp;</p><pre class="brush:java;toolbar:false">permissionResolver=com.liwei.permission.MyPermissionResolver\nauthorizer.permissionResolver=$permissionResolver\nsecurityManager.authorizer=$authorizer</pre><p style="white-space: normal;">此时 Shiro 会去这个配置文件中指定的&nbsp;PermissionResolver 找相应的实现类，通过“user:view”这个字符串去实现类中找到对应应该使用的 Permission 实现类，然后实例化一个 Permission 对象（<span style="color: rgb(255, 0, 0);"><strong>这个 Permission 对象很重要，我们暂时把它记住，下一步马上就要用来做匹配</strong></span>）。</p><p style="white-space: normal;"><br/></p><p style="white-space: normal;">3、在进行授权之前，其会调用相应的 Realm 获取 Subject 相应的角色/权限用于匹配传入的角色/权限；</p><p style="white-space: normal;">这个转换实例的过程就是在代码中通过在 Realm 中实现的&nbsp;doGetAuthorizationInfo() 方法里写的&nbsp;info.addObjectPermission(new MyPermission(&quot;+user+add+1&quot;)); 即构造函数实现的，<span style="color: rgb(255, 0, 0);"><strong>在这个过程中也实例化了一个 Permission 对象，用于和上一步的 Permission 对象进行比较，这个比较的过程是通过我们实现 Permission 接口中的 implies（） 方法来定义的</strong></span><strong>&nbsp;</strong>。</p><p style="white-space: normal;"><br/></p><p style="white-space: normal;">4、Authorizer 会判断 Realm 的角色/权限是否和传入的匹配，如果有多个 Realm，会委托给 ModularRealmAuthorizer 进行循环判断，如果匹配如 isPermitted*/hasRole*会返回 true，否则返回 false 表示授权失败。</p><p style="white-space: normal;"><br/></p><hr/><p style="white-space: normal;">下面继续说明如何自定义角色匹配，其实过程和自定义权限匹配是类似的，但是我们要明确一点，因为角色是一组权限的集合，所以我们指定角色解析器的时候，须要告诉 Shiro 使用什么 Permission 。<br/></p><p style="white-space: normal;">步骤1：实现&nbsp;RolePermissionResolver &nbsp;接口</p><pre class="brush:java;toolbar:false">public&nbsp;class&nbsp;MyRolePermissionResolver&nbsp;implements&nbsp;RolePermissionResolver&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;@Override\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Collection&lt;Permission&gt;&nbsp;resolvePermissionsInRole(String&nbsp;s)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(s.contains(&quot;role1&quot;)){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Arrays.asList((Permission)&nbsp;new&nbsp;MyPermission(&quot;+user+add+1&quot;));\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;null;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}</pre><p style="white-space: normal;">步骤2：在 shiro.ini 中配置我们的&nbsp;RolePermissionResolver&nbsp;</p><pre class="brush:java;toolbar:false">authorizer=org.apache.shiro.authz.ModularRealmAuthorizer\n\nrolePermissionResolver=com.liwei.role.MyRolePermissionResolver\nauthorizer.rolePermissionResolver=$rolePermissionResolver\n\npermissionResolver=com.liwei.permission.MyPermissionResolver\nauthorizer.permissionResolver=$permissionResolver\n\nsecurityManager.authorizer=$authorizer\nsecurityManager.realms=$myStaticRealm</pre><p style="white-space: normal;">步骤3：在自定义的 Realm 的授权方法中添加角色</p><pre class="brush:java;toolbar:false">public&nbsp;class&nbsp;MyStaticRealm&nbsp;extends&nbsp;AuthorizingRealm&nbsp;{\n\n&nbsp;&nbsp;&nbsp;&nbsp;/**\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;用于授权\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;principalCollection\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@return\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/\n&nbsp;&nbsp;&nbsp;&nbsp;@Override\n&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;AuthorizationInfo&nbsp;doGetAuthorizationInfo(PrincipalCollection&nbsp;principalCollection)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;static&nbsp;Realm&nbsp;中授权的方法&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SimpleAuthorizationInfo&nbsp;info&nbsp;=&nbsp;new&nbsp;SimpleAuthorizationInfo();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;info.addRole(&quot;role1&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;info;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n\n&nbsp;&nbsp;&nbsp;&nbsp;/**\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;用于认证\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;token\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@return\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@throws&nbsp;AuthenticationException\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/\n&nbsp;&nbsp;&nbsp;&nbsp;@Override\n&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;AuthenticationInfo&nbsp;doGetAuthenticationInfo(AuthenticationToken&nbsp;token)&nbsp;throws&nbsp;AuthenticationException&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;省略\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}</pre><p style="white-space: normal;">步骤 4 ：判断用户是否具有授权方法中指定角色的权限<br/></p><p style="white-space: normal;">代码片段：</p><pre class="brush:java;toolbar:false">currentSubject.checkPermission(&quot;+user+add+1&quot;);</pre><p style="white-space: normal;">（终于写完了，不知道能不能讲清楚这件事情，大家光看也是很难理解的，须要自己动手练习，多打出一些帮助理解的代码信息就可以很快理解了）。</p>', 1, 'Shiro');
INSERT INTO `t_blog` (`title`, `summary`, `release_date`, `click_hit`, `reply_hit`, `content`, `type_id`, `key_word`) VALUES
('Shiro 学习笔记（6）—— 加密', 'Shiro 有一个非常强大的功能，就是对加密算法的封装。在我们之前的例子中，我们的密码在 Realm 里返回认证信息的时候，写的都是明文。这样的方式其实是很不安全的。一般地，密码这样的高度敏感的字段，我们应该是使用一种不可破解的算法加密以后存储到我们的数据库中。当用户登录的时候，在用户输入用户名正确（在库中存', '2016-09-16 14:24:57', 3, 0, '<p style="white-space: normal;">Shiro 有一个非常强大的功能，就是对加密算法的封装。在我们之前的例子中，我们的密码在 Realm 里返回认证信息的时候，写的都是明文。这样的方式其实是很不安全的。</p><p style="white-space: normal;">一般地，密码这样的高度敏感的字段，我们应该是使用一种不可破解的算法加密以后存储到我们的数据库中。当用户登录的时候，在用户输入用户名正确（在库中存在）的前提下，将用户输入的密码使用同样的算法加密以后得到的字符串和数据库中的密文密码进行匹配，匹配成功，则认证通过。</p><p style="white-space: normal;">这样处理的好处是，即使是可以接触生产环境的开发人员或者是数据库管理人员，都无法通过数据库信息知道真实用户的密码。即使是密码泄露给外部，别人也无法知道密码的明文是什么，极大地保护了用户信息的安全。</p><p style="white-space: normal;"><br/></p><p style="white-space: normal;">Shiro 提供了 PasswordService 及 CredentialsMatcher 用于提供加密密码及验证密码服务。</p><p style="white-space: normal;">我们先来看一个例子：</p><pre class="brush:java;toolbar:false">PasswordService&nbsp;service&nbsp;=&nbsp;new&nbsp;DefaultPasswordService();\nString&nbsp;str1&nbsp;=&nbsp;service.encryptPassword(&quot;123456&quot;);\nString&nbsp;str2&nbsp;=&nbsp;service.encryptPassword(&quot;123456&quot;);\nSystem.out.println(str1);\nSystem.out.println(str2);\n//&nbsp;盐值是存放在加密以后的密码中的\nboolean&nbsp;boolean1&nbsp;=&nbsp;service.passwordsMatch(&quot;123456&quot;,str1);\nSystem.out.println(boolean1);\nboolean&nbsp;boolean2&nbsp;=&nbsp;service.passwordsMatch(&quot;123456&quot;,str2);\nSystem.out.println(boolean2)</pre><p style="white-space: normal;">我们发现，同样是“123456”这样的密码，使用&nbsp;DefaultPasswordService 这个实现类的&nbsp;encryptPassword() 方法加密以后得到的密文都是不一样的。但是我们可以使用&nbsp;DefaultPasswordService 这个实现类的&nbsp;passwordsMatch() 将明文密码与密文密码进行匹配，使用这个方法匹配是成功可靠的，这一点我们须要理解。</p><p style="white-space: normal;">那么，我们如何在 Realm 中指定 Shiro 使用&nbsp;DefaultPasswordService 这个实现类的&nbsp;passwordsMatch() 方法进行密码的匹配呢？</p><p style="white-space: normal;">我们可以使用依赖注入的方式，代码如下：</p><p style="white-space: normal;">自定义 Realm 的认证实现部分：</p><pre class="brush:java;toolbar:false">public&nbsp;class&nbsp;MyPasswordRealm&nbsp;extends&nbsp;AuthorizingRealm&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;@Override\n&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;AuthorizationInfo&nbsp;doGetAuthorizationInfo(PrincipalCollection&nbsp;principalCollection)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;null;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n\n&nbsp;&nbsp;&nbsp;&nbsp;@Override\n&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;AuthenticationInfo&nbsp;doGetAuthenticationInfo(AuthenticationToken&nbsp;authenticationToken)&nbsp;throws&nbsp;AuthenticationException&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;username&nbsp;&nbsp;=&nbsp;authenticationToken.getPrincipal().toString();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;String&nbsp;password&nbsp;=&nbsp;new&nbsp;String((char[])&nbsp;authenticationToken.getCredentials());\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;此时我们应该从数据库中根据&nbsp;username&nbsp;查询出对应的密码\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;String&nbsp;passwordFromDB&nbsp;=&nbsp;&quot;$shiro1$SHA-256$500000$tSqKNsDkQ4hLsGwJ9JnNUw==$7UxMi+gx5OjIdu8knQdrWlB0RDfWDEF/LwxjL0JdDRs=&quot;;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;String&nbsp;passwordFromDB&nbsp;=&nbsp;&quot;$shiro1$SHA-256$500000$79CtWg6E9u4Bxp0v7BNpxA==$eKAezOeAAQrS2cxTDJZJM8vwovgbCXrqRFSHvbgaMEY=&quot;;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;passwordFromDB&nbsp;=&nbsp;&quot;$shiro1$SHA-256$500000$b282jV6ARlycFe0B4OaUQA==$9r6F9OdmO/kvy0ig0FZbEg9etkJ7hd+10CTS1rRjUdo=&quot;;\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SimpleAuthenticationInfo&nbsp;info=&nbsp;new&nbsp;SimpleAuthenticationInfo(username,passwordFromDB,getName());\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;info;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}</pre><p style="white-space: normal;">如果我们不指定 Realm 使用&nbsp;PasswordMatcher 的实现类的话，默认的匹配方式就是使用字符串是否相同这样的匹配方式，显然不能达到我们的要求。所以我们要在 Realm 中指定&nbsp;PasswordMatcher 的属性：</p><pre class="brush:java;toolbar:false">#&nbsp;声明一个&nbsp;Shiro&nbsp;已经有的密码匹配的类\npasswordMatcher=org.apache.shiro.authc.credential.PasswordMatcher\n#&nbsp;声明自定义的&nbsp;Realm&nbsp;类\nmyPasswordRealm=com.liwei.realm.MyPasswordRealm\n#&nbsp;将&nbsp;passwordMatcher&nbsp;注入到自定义的&nbsp;Realm&nbsp;类中\nmyPasswordRealm.credentialsMatcher=$passwordMatcher\n#&nbsp;将自定义的&nbsp;Realm&nbsp;注入到&nbsp;securityManager&nbsp;中\nsecurityManager.realms=$myPasswordRealm</pre><p style="white-space: normal;">这样，密文密码匹配的功能就实现了。</p><hr/><p style="white-space: normal;">实际应用中，我们喜欢自己定义加密的算法，例如 MD5 算法，我们还可以为 MD5 算法指定盐值，让 MD5 加密得到的密文更加安全。</p><p style="white-space: normal;">我们首先介绍使用 MD5 算法，通过加盐的方式得到 “123456” 的密文。</p><pre class="brush:java;toolbar:false">String&nbsp;originPassword&nbsp;=&nbsp;&quot;123456&quot;;\nString&nbsp;salt&nbsp;=&nbsp;&quot;hello&quot;;\nString&nbsp;md5&nbsp;=&nbsp;new&nbsp;Md5Hash(originPassword,salt).toString();\nSystem.out.println(md5);</pre><p style="white-space: normal;">接下来编写自定义 Realm 中的认证实现部分。<br/></p><pre class="brush:java;toolbar:false">public&nbsp;class&nbsp;MyPasswordRealm&nbsp;extends&nbsp;AuthorizingRealm&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;@Override\n&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;AuthorizationInfo&nbsp;doGetAuthorizationInfo(PrincipalCollection&nbsp;principalCollection)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;null;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n\n&nbsp;&nbsp;&nbsp;&nbsp;@Override\n&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;AuthenticationInfo&nbsp;doGetAuthenticationInfo(AuthenticationToken&nbsp;authenticationToken)&nbsp;throws&nbsp;AuthenticationException&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;username&nbsp;&nbsp;=&nbsp;authenticationToken.getPrincipal().toString();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;String&nbsp;password&nbsp;=&nbsp;new&nbsp;String((char[])&nbsp;authenticationToken.getCredentials());\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;此时我们应该从数据库中根据&nbsp;username&nbsp;查询出对应的密码\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;passwordFromDB&nbsp;=&nbsp;&quot;eeb9bad681184779aa6570e402d6ef6c&quot;;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;salt&nbsp;=&nbsp;&quot;hello&quot;;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SimpleAuthenticationInfo&nbsp;info=&nbsp;new&nbsp;SimpleAuthenticationInfo(username,passwordFromDB,getName());\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;设置加密算法的盐值，使用&nbsp;ByteSource&nbsp;这个工具类\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;info.setCredentialsSalt(ByteSource.Util.bytes(salt.getBytes()));\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;info;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}</pre><p style="white-space: normal;">最后，我们要在 shiro.ini 配置文件中配置密码匹配的类（配置加密算法和盐值）：</p><pre class="brush:java;toolbar:false">#&nbsp;声明一个&nbsp;Shiro&nbsp;已经有的密码匹配的类\nhashMatcher=org.apache.shiro.authc.credential.HashedCredentialsMatcher\nhashMatcher.hashAlgorithmName=md5\nhashMatcher.hashSalted=hello\n#&nbsp;声明自定义的&nbsp;Realm&nbsp;类\nmyPasswordRealm=com.liwei.realm.MyPasswordRealm\n#&nbsp;将&nbsp;passwordMatcher&nbsp;注入到自定义的&nbsp;Realm&nbsp;类中\nmyPasswordRealm.credentialsMatcher=$hashMatcher\n#&nbsp;将自定义的&nbsp;Realm&nbsp;注入到&nbsp;securityManager&nbsp;中\nsecurityManager.realms=$myPasswordRealm</pre><p style="white-space: normal;">到这里，加密的部分就简单介绍完成了，我们看到，主要还是通过配置的方式，使得我们的认证更加安全和规范。</p>', 1, 'Shiro'),
('Shiro 学习笔记（7）—— Shiro 集成 Web', '在 Web 环境下集成 Shiro 其实不难，按照官方文本的说明实现就可以了。更多地，我们会在 Spring 的 Web 环境中使用 Shiro ，这个我们后面再讲。参考 Shiro 官方文档中集成 Web 的这个章节：http://shiro.apache.org/webapp-tutorial.html。', '2016-09-16 16:19:39', 7, 0, '<p>在 Web 环境下集成 Shiro 其实不难，按照官方文本的说明实现就可以了。更多地，我们会在 Spring 的 Web 环境中使用 Shiro ，这个我们后面再讲。</p><p>参考 Shiro 官方文档中集成 Web 的这个章节：<a href="http://shiro.apache.org/webapp-tutorial.html。">http://shiro.apache.org/webapp-tutorial.html。</a> </p><p>步骤1：</p><p>在 web.xml 部署描述符中配置 Shiro。</p><pre class="brush:java;toolbar:false">&lt;listener&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;listener-class&gt;org.apache.shiro.web.env.EnvironmentLoaderListener&lt;/listener-class&gt;\n&lt;/listener&gt;\n\n&lt;filter&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;filter-name&gt;ShiroFilter&lt;/filter-name&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;filter-class&gt;org.apache.shiro.web.servlet.ShiroFilter&lt;/filter-class&gt;\n&lt;/filter&gt;\n\n&lt;filter-mapping&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;filter-name&gt;ShiroFilter&lt;/filter-name&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;dispatcher&gt;INCLUDE&lt;/dispatcher&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;dispatcher&gt;ERROR&lt;/dispatcher&gt;\n&lt;/filter-mapping&gt;</pre><p>步骤2：配置 shiro.ini<br/></p><p>默认的情况下，Shiro 使用的核心配置文件就是在 WEB-INF/classes 根路径下的 shiro.ini 。如果你使用的是 Maven 或者 Gradle 构建，可以把 shiro.ini 文件放在 resources 目录下。</p><p>下面这个配置文件，我都写了详细的每一项配置的说明。</p><pre class="brush:java;toolbar:false">\n\n[main]\n#&nbsp;身份认证不通过的用户，Shiro&nbsp;会帮助跳转（Get）到一个地址\n#&nbsp;这个地址只能是站内的一个地址\nauthc.loginUrl=/login\n#&nbsp;在身份认证成功的前提下，用户不具有相应的角色，跳转（Get）到下面这个链接\nroles.unauthorizedUrl=/unauthorized-noRole.jsp\n#&nbsp;在身份认证成功的前提下，用户不具有相应的权限，跳转（Get）到下面这个链接\nperms.unauthorizedUrl=/unauthorized-noPermission.jsp\n\n[users]\n#&nbsp;用户&nbsp;liwei&nbsp;具有角色&nbsp;admin\nliwei=123456,admin\nzhouguang=666666,teacher\nyuanlian=888888\nlirui=999999\n\n[roles]\n#&nbsp;admin&nbsp;角色的定义\nadmin=user:*\n#&nbsp;teacher&nbsp;角色的定义\nteacher=student:*\n\n[urls]\n#&nbsp;访问&nbsp;/login&nbsp;不须要身份认证\n/login=anon\n#&nbsp;访问&nbsp;/admin&nbsp;须要身份认证\n/admin=authc\n#&nbsp;访问&nbsp;/student&nbsp;不仅须要身份认证，而且还要具有角色&nbsp;teacher\n/student=roles[teacher]\n#&nbsp;访问&nbsp;/teacher&nbsp;不仅须要身份认证，而且还要具有权限&nbsp;&quot;user:create&quot;\n/teacher=perms[&quot;user:create&quot;]</pre><p>步骤3：编写登录认证的代码。</p><p>以前我们写的测试代码中有一句 SecurityUtil.setSecurityManager(securityManager) ，在 Web 集成了 Shiro 以后，我们不用写这一句，就可以完成认证的操作。</p><p>以下是示例代码。</p><pre class="brush:java;toolbar:false">@WebServlet(name&nbsp;=&nbsp;&quot;LoginServlet&quot;,urlPatterns&nbsp;=&nbsp;{&quot;/login&quot;})\npublic&nbsp;class&nbsp;LoginServlet&nbsp;extends&nbsp;HttpServlet&nbsp;{\n\n&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;void&nbsp;doPost(HttpServletRequest&nbsp;request,&nbsp;HttpServletResponse&nbsp;response)&nbsp;throws&nbsp;ServletException,&nbsp;IOException&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;login&nbsp;post&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;userName&nbsp;=request.getParameter(&quot;userName&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;password&nbsp;=request.getParameter(&quot;password&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;因为&nbsp;SecurityUtil.setSecurityManager(securityManager)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;这件事情都交给了&nbsp;web.xml&nbsp;配置的监听器来完成了，所以这里不用写了\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Subject&nbsp;currentUser&nbsp;=&nbsp;SecurityUtils.getSubject();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UsernamePasswordToken&nbsp;token&nbsp;=&nbsp;new&nbsp;UsernamePasswordToken(userName,password,&quot;xx&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currentUser.login(token);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;登录成功以后重定向跳转到&nbsp;success.jsp\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.sendRedirect(&quot;success.jsp&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}catch&nbsp;(UnknownAccountException&nbsp;e){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;无效的用户名&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request.setAttribute(&quot;errorInfo&quot;,&nbsp;&quot;用户名错误&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request.getRequestDispatcher(&quot;login.jsp&quot;).forward(request,&nbsp;response);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}catch&nbsp;(IncorrectCredentialsException&nbsp;e){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;错误的密码&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request.setAttribute(&quot;errorInfo&quot;,&nbsp;&quot;密码错误&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request.getRequestDispatcher(&quot;login.jsp&quot;).forward(request,&nbsp;response);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}catch&nbsp;(AuthenticationException&nbsp;e)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request.setAttribute(&quot;errorInfo&quot;,&nbsp;&quot;其它&nbsp;AuthenticationException&nbsp;&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request.getRequestDispatcher(&quot;login.jsp&quot;).forward(request,&nbsp;response);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;这里不能用&nbsp;currentUser.logout();&nbsp;否则每次进来都要验证\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;currentUser.logout();\n&nbsp;&nbsp;&nbsp;&nbsp;}\n\n&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;void&nbsp;doGet(HttpServletRequest&nbsp;request,&nbsp;HttpServletResponse&nbsp;response)&nbsp;throws&nbsp;ServletException,&nbsp;IOException&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;login&nbsp;get&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request.getRequestDispatcher(&quot;login.jsp&quot;).forward(request,&nbsp;response);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}</pre><p>其实这个时候项目的大题框架已经建好了，后面再有就是一些页面的设置，在这里就不多展示代码，占用文章篇幅了，大家可以下载我的代码，在本地跑起来自己测试一下。最最核心的是要理解 shiro.ini 这个核心配置文件每一项的意义，然后进行相应的测试。</p>', 1, 'Shiro');


